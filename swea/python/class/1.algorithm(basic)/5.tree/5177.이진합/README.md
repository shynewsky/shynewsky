# ⭐부모인덱스 [i//2], 자식인덱스 [i*2][i*2+1]⭐

### 완전이진트리(CBT, Complete Binary Tree)

- 굳이 빈 포화이진트리 만들어서 LVR 하지 않아도 된다

| | |
|---|---|
|배열형태|- 빈 트리 만든 후에, 항상 맨뒤에 append 하면 자동으로 완전이진트리 유지<br> - 순회할때는 [i*2], [i*2+1]로 접근한다|
|클래스|- self.v, self.left, self.right 인스턴스 변수로 저장한다|

- 0-indexed, 1-indexed

| | |
|---|---|
|0-indexed|[0]부터 값 채움 (대부분 언어)|
|1-indexed|[0] 비우고, [1]부터 채움 (힙, 수학적트리 표현 등에 사용)|

---

### (자식인덱스)//2 = (부모인덱스) 가 되는 원리

```python
         [1]
       /     \
     [2]     [3]
    /  \     /  \
  [4] [5]  [6] [7]
  
  tree = [0, 1, 2, 3, 4, 5, 6, 7] (0은 더미 자리)
``` 

|노드번호|부모|왼자식|오른자식|
|---|---|---|---|
|1|-|2|3|
|2|1|4|5|
|3|1|6|7|
|4|2|-|-|
|5|2|-|-|
|6|3|-|-|
|7|3|-|-|


|레벨|노드 개수|인덱스 범위|
|---|---|---|
|1|1|1|
|2|2|2~3|
|3|4|4~7|
|4|8|8~15|

|관계|계산식|
|---|---|
|부모 인덱스|i // 2|
|왼쪽 자식|i * 2|
|오른쪽 자식|i * 2 + 1|


### 이진 최소 힙(min-heap) 작동 원리

- 입력된 숫자들을 순서대로 삽입한다
- 힙은 전체를 정렬하는 구조가 아니라, 부모<=자식 관계만 유지하는 부분정렬 구조
- 따라서 sort() 를 사용하는 것이 아니라, 원소 자리 교환 알고리즘을 사용한다

```python
18, 57, 11, 52, 14, 45, 63, 40
```
```python
18
▶ [0, 18] ▶ [0, 18]

57
▶ [0, 18, 57] ▶ 부모 = 1 
▶ 57 > 18 stop ▶ [0, 18, 57]

11
▶ [0, 18, 57, 11] ▶ 부모 = 1 
▶ 11 < 18 swap  ▶ [0, 11, 57, 18]

52
▶[0, 11, 57, 18, 52] ▶ 부모 = 2
▶ 52 < 57 swap  ▶ [0, 11, 52, 18, 57]

14
▶[0, 11, 52, 18, 57, 14] ▶ 부모 = 2
▶ 14 < 52 swap ▶ 부모 = 1
▶ 14 > 11 stop ▶ [0, 11, 14, 18, 57, 52]

45
▶[0, 11, 14, 18, 57, 52, 45] ▶ 부모 = 3
▶ 45 > 18 stop ▶ [0, 11, 14, 18, 57, 52, 45]

63
▶[0, 11, 14, 18, 57, 52, 45, 63] ▶ 부모 = 4
▶ 63 > 57 stop ▶ [0, 11, 14, 18, 57, 52, 45, 63]

40
▶[0, 11, 14, 18, 57, 52, 45, 63, 40] ▶ 부모 = 4
▶ 40 < 57 swap ▶ 부모 = 2
▶ 40 > 14 stop ▶ [0, 11, 14, 18, 40, 52, 45, 63, 57]
```
```python
            11
       ┌──────────┐
      14          18
   ┌────┐       ┌────┐
  40    52     45    63
 /
57
```

---

### 내 코드

```python
"마지막 노드의 조상 노드에 저장된 정수의 합"
힙의 마지막 노드에서 시작해, 부모를 따라 올라가며 값의 합을 구한다
```
```python
import sys
sys.stdin = open('input.txt')

# 1. 이진 최소 힙 -------------------------------------------
def heappush(x):
    heap.append(x)      # 일단 뒤에 붙이고
    i = len(heap) - 1   # 해당 원소의 인덱스를 구한다
    while i > 1:
        p = i // 2      # 해당 원소의 부모 인덱스는, 현재위치의 절반이다
        if heap[i] < heap[p]:
            heap[i], heap[p] = heap[p], heap[i]
            i = p
        else:
            break

# 2. 마지막 노드의 조상 노드에 저장된 정수의 합 -------------------
# 힙의 마지막 노드에서 시작해, 부모를 따라 올라가며 값의 합을 구한다
def func():
    idx = len(heap) - 1    # 마지막 노드
    total = 0
    while idx > 1:
        idx //= 2          # 부모로 이동
        total += heap[idx] # 부모 값 더하기
    return total

# 입력 -----------------------------------------------------
T = int(input())
for t in range(1, T+1):
    N = int(input())
    data = list(map(int, input().split()))

# 코드 ----------------------------------------------------
    heap = [0] # 1-indexed
    for x in data:
        heappush(x)
    answer = func()

# 출력 ----------------------------------------------------
    print(f'#{t}', answer)
```