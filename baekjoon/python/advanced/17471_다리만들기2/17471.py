import sys
sys.stdin = open('input.txt')
from collections import deque
from pprint import pprint

'''
수업예제 "섬찾기"
- 이중for문으로 행렬을 순회하며,
- 1을 발견하면 delta를 활용한 BFS로 모든땅을 방문처리 + 섬개수증가
'''
'''
- 각각 다른 섬이라고 구분해야한다 = union-find (대표자로 구분)
- 4방향 델타를 활용해서 다리를 놓는다 = DFS (한방향으로 먼저 가보기)
- 모든 섬이 연결되어 있어야 한다 = 최소비용신장트리 (prim, kruskal)
    - 다리길이 = 간선 가중치
'''

# 함수 -------------------------------------------------------------------

# union-find ------------------------------------------------------------

def find_set(node):
    x, y = node
    if (x, y) == parents[x][y]:
        return (x, y)
    parents[x][y] = find_set(parents[x][y])
    return parents[x][y]

def union_set(x, y):
    rx = find_set(x)
    ry = find_set(y)
    if rx == ry:
        return
    rx_x, rx_y = rx
    ry_x, ry_y = ry
    parents[ry_x][ry_y] = rx
    nodes.add(rx)

# delta를 활용한 bfs로 섬 영역찾기 --------------------------------------------

def bfs(start_node):

    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]

    q = deque([start_node])
    start_x, start_y = start_node
    visited[start_x][start_y] = 1

    while q:
        x, y = q.popleft()

        for i in range(4): # delta
            nx, ny = x+dx[i], y+dy[i]
            if 0<=nx<N and 0<=ny<M and mat[nx][ny] ==1 and visited[nx][ny] == 0:
                q.append((nx, ny))
                visited[nx][ny] = 1
                union_set((x,y), (nx,ny))

# 입력 -------------------------------------------------------------------------
N, M = map(int, input().split()) # N행 M열
mat = [list(map(int, input().split())) for _ in range(N)]

# 코드 -------------------------------------------------------------------------

# make_set() : 자기자신을 부모로 갖는 집합
parents = [[(i,j) for j in range(M)] for i in range(N)]
'''
# parents
[[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7)],
 [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7)],
 [(2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7)],
 [(3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7)],
 [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7)],
 [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7)],
 [(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7)]]
'''

# bfs로 섬을 찾으면서 union_set()으로 대표자 합치기
visited = [[0] * M for _ in range(N)] # 방문표시
nodes = set() # 대표자 집합
for i in range(N): # 행순회
    for j in range(M): # 열순회
        if mat[i][j] == 1 and visited[i][j] == 0:
            bfs((i,j))
'''
# visited
[[0, 0, 0, 0, 0, 0, 1, 1],
 [1, 1, 0, 0, 0, 0, 1, 1],
 [1, 1, 0, 0, 0, 0, 0, 0],
 [1, 1, 0, 0, 0, 1, 1, 0],
 [0, 0, 0, 0, 0, 1, 1, 0],
 [0, 0, 0, 0, 0, 0, 0, 0],
 [1, 1, 1, 1, 1, 1, 1, 1]]

# parents
[[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 6)],
 [(1, 0), (1, 0), (1, 2), (1, 3), (1, 4), (1, 5), (0, 6), (0, 6)],
 [(1, 0), (1, 0), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7)],
 [(1, 0), (1, 0), (3, 2), (3, 3), (3, 4), (3, 5), (3, 5), (3, 7)],
 [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (3, 5), (3, 5), (4, 7)],
 [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7)],
 [(6, 0), (6, 0), (6, 0), (6, 0), (6, 0), (6, 0), (6, 0), (6, 0)]]
 
# nodes
{(0, 6), (1, 0), (3, 5), (6, 0)}
'''

# dfs로
pprint(nodes)

