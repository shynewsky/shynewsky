import sys
sys.stdin = open('input.txt')
from collections import deque
from pprint import pprint
INF = float('inf')

'''
수업예제 "섬찾기"
- 이중for문으로 행렬을 순회하며,
- 1을 발견하면 delta를 활용한 BFS로 모든땅을 방문처리 + 섬개수증가
'''
'''
- 각각 다른 섬이라고 구분해야한다 = union-find (대표자로 구분)
- 4방향 델타를 활용해서 다리를 놓는다 = DFS (한방향으로 먼저 가보기)
- 모든 섬이 연결되어 있어야 한다 = 최소비용신장트리 (prim, kruskal)
    - 다리길이 = 간선 가중치
'''

# 함수 -------------------------------------------------------------------

# union-find ------------------------------------------------------------

def find_set(node):
    x, y = node
    if (x, y) == parents[x][y]:
        return (x, y)
    parents[x][y] = find_set(parents[x][y])
    return parents[x][y]

def union_set(x, y):
    rx = find_set(x)
    ry = find_set(y)
    if rx == ry:
        return
    rx_x, rx_y = rx
    ry_x, ry_y = ry
    parents[ry_x][ry_y] = rx

    # nodes.add(rx)

    dict[rx] += dict[ry]
    del dict[ry]

# delta를 활용한 bfs로 섬 영역찾기 --------------------------------------------

def bfs(start_node):

    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]

    q = deque([start_node])
    start_x, start_y = start_node
    visited[start_x][start_y] = 1

    # 둘러싸인 이웃이 없으면 추가되지 않음
    # nodes.add(find_set(start_node))

    while q:
        x, y = q.popleft()

        for i in range(4): # delta
            nx, ny = x+dx[i], y+dy[i]
            if 0<=nx<N and 0<=ny<M and mat[nx][ny] == 1 and visited[nx][ny] == 0:
                q.append((nx, ny))
                visited[nx][ny] = 1
                union_set((x,y), (nx,ny))

# delta로 가중치 찾기 ----------------------------------------------

def kruksal():

    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]

    edges = []  # 간선리스트

    # 그래프 그리기
    for i in range(V-1):  # nodes 순회
        for j in range(i+1, V):  # 조합
            n1, n2 = nodes[i], nodes[j]
            '''
            (0, 6) (1, 0)
            (0, 6) (3, 5)
            (0, 6) (6, 0)
            (1, 0) (3, 5)
            (1, 0) (6, 0)
            (3, 5) (6, 0)
            '''
            # 최소 간선 가중치 구하기
            for current_node in dict[n1]:  # (0, 6), (0, 7), (1, 6), (1, 7)
                w = INF  # 다리길이(w) 초기화

                for d in range(4):  # delta (0,-1), (0,1), (-1,0), (1,0)
                    x, y = current_node  # 방향 바꿀때마다 원위치
                    nw = 0

                    while True:
                        nx, ny = x + dx[d], y + dy[d]

                        if not (0 <= nx < N and 0 <= ny < M):  # 범위 나가면 실패
                            break

                        if mat[nx][ny] == 0:  # 바다면 다리길이 +1
                            nw += 1

                        # if mat[nx][ny] == 1 and parents[nx][ny] != n2:  # 육지인데, 목적지가 아니면
                        #     break
                        #
                        # if parents[nx][ny] == n2 and nw >= 2:  # 목적지일때, 길이 최소 구해서 간선리스트에 추가
                        #     if w > nw:
                        #         w = nw
                        #     edges.append((n1, n2, w))
                        #     break

                        # BFS로 합치기만 하고 find_set 을 하지 않은 경우 문제가 생길 수 있다
                        root = find_set((nx, ny))
                        if mat[nx][ny] == 1 and root != n2:  # 다른 섬(목적지 아님) 만나면 중단
                            break
                        if root == n2 and nw >= 2:  # 목적 섬 도착 + 길이 조건
                            w = min(w, nw)
                            # 여기서 edges에 추가

                        x, y = nx, ny

    return edges

# 섬을 잇기위한 union-find ------------------------------------------------------

def union_island(x, y):
    rx = find_set(x)
    ry = find_set(y)
    if rx == ry:
        return
    rx_x, rx_y = rx
    ry_x, ry_y = ry
    parents[ry_x][ry_y] = rx

# 입력 -------------------------------------------------------------------------
N, M = map(int, input().split()) # N행 M열
mat = [list(map(int, input().split())) for _ in range(N)]

# 코드 -------------------------------------------------------------------------

# make_set() : 자기자신을 부모로 갖는 집합
parents = [[(i,j) for j in range(M)] for i in range(N)]
dict = {node : [node] for row in parents for node in row}
'''
# parents
[[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7)],
 [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7)],
 [(2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7)],
 [(3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7)],
 [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7)],
 [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7)],
 [(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7)]]
 
# dict
{(0, 0): [(0, 0)],
 (0, 1): [(0, 1)],
 (0, 2): [(0, 2)],
 (0, 3): [(0, 3)],
 (0, 4): [(0, 4)],
 (0, 5): [(0, 5)],
 (0, 6): [(0, 6)],
 (0, 7): [(0, 7)],
 (1, 0): [(1, 0)],
 (1, 1): [(1, 1)],
 (1, 2): [(1, 2)],
 (1, 3): [(1, 3)],
 (1, 4): [(1, 4)],
 (1, 5): [(1, 5)],
 (1, 6): [(1, 6)],
 (1, 7): [(1, 7)],
 (2, 0): [(2, 0)],
 (2, 1): [(2, 1)],
 (2, 2): [(2, 2)],
 (2, 3): [(2, 3)],
 (2, 4): [(2, 4)],
 (2, 5): [(2, 5)],
 (2, 6): [(2, 6)],
 (2, 7): [(2, 7)],
 (3, 0): [(3, 0)],
 (3, 1): [(3, 1)],
 (3, 2): [(3, 2)],
 (3, 3): [(3, 3)],
 (3, 4): [(3, 4)],
 (3, 5): [(3, 5)],
 (3, 6): [(3, 6)],
 (3, 7): [(3, 7)],
 (4, 0): [(4, 0)],
 (4, 1): [(4, 1)],
 (4, 2): [(4, 2)],
 (4, 3): [(4, 3)],
 (4, 4): [(4, 4)],
 (4, 5): [(4, 5)],
 (4, 6): [(4, 6)],
 (4, 7): [(4, 7)],
 (5, 0): [(5, 0)],
 (5, 1): [(5, 1)],
 (5, 2): [(5, 2)],
 (5, 3): [(5, 3)],
 (5, 4): [(5, 4)],
 (5, 5): [(5, 5)],
 (5, 6): [(5, 6)],
 (5, 7): [(5, 7)],
 (6, 0): [(6, 0)],
 (6, 1): [(6, 1)],
 (6, 2): [(6, 2)],
 (6, 3): [(6, 3)],
 (6, 4): [(6, 4)],
 (6, 5): [(6, 5)],
 (6, 6): [(6, 6)],
 (6, 7): [(6, 7)]}
'''
# pprint(dict)

# bfs + delta 로 섬을 찾으면서 union_set()으로 대표자 합치기
visited = [[0] * M for _ in range(N)] # 방문표시
nodes = set() # 대표자 집합
for i in range(N): # 행순회
    for j in range(M): # 열순회
        if mat[i][j] == 1 and visited[i][j] == 0:
            bfs((i,j))
# nodes = sorted(list(nodes))
nodes = sorted(list({
    find_set((i,j))
    for i in range(N) for j in range(M)
    if mat[i][j] == 1
}))
V = len(nodes)
'''
# visited
[[0, 0, 0, 0, 0, 0, 1, 1],
 [1, 1, 0, 0, 0, 0, 1, 1],
 [1, 1, 0, 0, 0, 0, 0, 0],
 [1, 1, 0, 0, 0, 1, 1, 0],
 [0, 0, 0, 0, 0, 1, 1, 0],
 [0, 0, 0, 0, 0, 0, 0, 0],
 [1, 1, 1, 1, 1, 1, 1, 1]]

# parents
[[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 6)],
 [(1, 0), (1, 0), (1, 2), (1, 3), (1, 4), (1, 5), (0, 6), (0, 6)],
 [(1, 0), (1, 0), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7)],
 [(1, 0), (1, 0), (3, 2), (3, 3), (3, 4), (3, 5), (3, 5), (3, 7)],
 [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (3, 5), (3, 5), (4, 7)],
 [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7)],
 [(6, 0), (6, 0), (6, 0), (6, 0), (6, 0), (6, 0), (6, 0), (6, 0)]]

# dict
{(0, 0): [(0, 0)],
 (0, 1): [(0, 1)],
 (0, 2): [(0, 2)],
 (0, 3): [(0, 3)],
 (0, 4): [(0, 4)],
 (0, 5): [(0, 5)],
 (0, 6): [(0, 6), (0, 7), (1, 6), (1, 7)],
 (1, 0): [(1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)],
 (1, 2): [(1, 2)],
 (1, 3): [(1, 3)],
 (1, 4): [(1, 4)],
 (1, 5): [(1, 5)],
 (2, 2): [(2, 2)],
 (2, 3): [(2, 3)],
 (2, 4): [(2, 4)],
 (2, 5): [(2, 5)],
 (2, 6): [(2, 6)],
 (2, 7): [(2, 7)],
 (3, 2): [(3, 2)],
 (3, 3): [(3, 3)],
 (3, 4): [(3, 4)],
 (3, 5): [(3, 5), (3, 6), (4, 5), (4, 6)],
 (3, 7): [(3, 7)],
 (4, 0): [(4, 0)],
 (4, 1): [(4, 1)],
 (4, 2): [(4, 2)],
 (4, 3): [(4, 3)],
 (4, 4): [(4, 4)],
 (4, 7): [(4, 7)],
 (5, 0): [(5, 0)],
 (5, 1): [(5, 1)],
 (5, 2): [(5, 2)],
 (5, 3): [(5, 3)],
 (5, 4): [(5, 4)],
 (5, 5): [(5, 5)],
 (5, 6): [(5, 6)],
 (5, 7): [(5, 7)],
 (6, 0): [(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7)]}

# nodes
[(0, 6), (1, 0), (3, 5), (6, 0)]
'''
# pprint(nodes)
# pprint(dict)

# delta 로 길이 2이상의 다리 모두 찾아 kruskal 간선리스트 만들기 (n1, n2, w)
edges = kruksal()
edges.sort(key=lambda x : x[2])
'''
[((1, 0), (6, 0), 2),
 ((1, 0), (6, 0), 2),
 ((1, 0), (3, 5), 3),
 ((0, 6), (1, 0), 4),
 ((0, 6), (6, 0), 4)]
'''
# pprint(edges)

# kruskal로, 가장 작은 가중치 간선부터 선택하여 union 한다
cnt = 0         # 선택한 간선의 수
min_weight = 0  # 가중치의 합

for n1, n2, w in edges:
    if find_set(n1) != find_set(n2): # 이어져있지 않으면 잇는다
        union_island(n1, n2)
        cnt += 1
        min_weight += w

        if cnt == V-1: # 모든 섬을 연결하면
            break

# 출력 ----------------------------------------------------------------------

# print(min_weight if min_weight > 0 else -1)
if V <= 1:
    print(0)              # 섬이 0개/1개면 다리 0
elif cnt == V - 1:
    print(min_weight)     # 모두 연결 성공
else:
    print(-1)             # 연결 실패

